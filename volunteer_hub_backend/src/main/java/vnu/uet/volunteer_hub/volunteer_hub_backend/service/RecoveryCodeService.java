package vnu.uet.volunteer_hub.volunteer_hub_backend.service;

import java.time.Duration;
import java.util.Objects;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.stereotype.Service;

/**
 * Service lưu và kiểm tra secure token cho password recovery trong Redis.
 *
 * Security features:
 * - Sử dụng secure random token (32 bytes) thay vì mã số ngắn
 * - Lưu token -> email mapping với TTL configurable (mặc định 15 phút)
 * - One-time use: token tự động bị xóa sau khi validate thành công
 * - Không log token value để tránh leak
 */
@Service
public class RecoveryCodeService {

    private static final Logger logger = LoggerFactory.getLogger(RecoveryCodeService.class);

    private final StringRedisTemplate redisTemplate;
    private final Duration ttl;

    public RecoveryCodeService(StringRedisTemplate redisTemplate,
            @Value("${recovery.token.ttl-minutes:15}") long ttlMinutes) {
        this.redisTemplate = redisTemplate;
        this.ttl = Duration.ofMinutes(ttlMinutes);
    }

    private String tokenKey(String token) {
        return "pwd-reset:token:" + token;
    }

    private String emailKey(String email) {
        return "pwd-reset:email:" + (email == null ? "" : email.toLowerCase());
    }

    /**
     * Lưu password reset token (one-time) cho email vào Redis với TTL cấu hình.
     * 
     * @param email email của user
     * @param token secure random token (generated by TokenUtil)
     */
    public void storeRecoveryCode(String email, String token) {
        Objects.requireNonNull(email, "email must not be null");
        Objects.requireNonNull(token, "token must not be null");

        String tk = tokenKey(token);
        String ek = emailKey(email);

        try {
            // Lưu token -> email mapping (primary lookup)
            redisTemplate.opsForValue().set(tk, email, ttl);
            // Lưu email -> token mapping (để có thể invalidate old token khi tạo mới)
            redisTemplate.opsForValue().set(ek, token, ttl);
            logger.info("Stored password reset token for email={} with TTL={}s", email, ttl.getSeconds());
        } catch (Exception e) {
            logger.error("Failed to store password reset token in Redis for email={}", email, e);
            throw e;
        }
    }

    /**
     * Kiểm tra xem token có hợp lệ không. Nếu hợp lệ, trả về email liên quan và
     * xóa token (one-time use). Nếu không hợp lệ hoặc đã hết hạn thì trả về null.
     * 
     * @param inputToken token từ client gửi lên
     * @return email nếu token hợp lệ, null nếu không hợp lệ hoặc đã hết hạn
     */
    public String isValidRecoveryCode(String inputToken) {
        if (inputToken == null || inputToken.isBlank()) {
            return null;
        }

        String tk = tokenKey(inputToken);
        String email = redisTemplate.opsForValue().get(tk);
        if (email == null) {
            logger.warn("Password reset token not found or expired");
            return null;
        }

        // Consume token: delete both keys (single-use)
        try {
            String ek = emailKey(email);
            redisTemplate.delete(tk);
            redisTemplate.delete(ek);
            logger.info("Consumed password reset token for email={}", email);
        } catch (Exception e) {
            logger.warn("Failed to fully consume password reset token for email={}: {}", email, e.getMessage());
        }

        return email;
    }

    /**
     * Hủy token theo email (invalidate existing token khi user request token mới).
     * Không gây lỗi nếu không tồn tại.
     * 
     * @param email email của user
     */
    public void invalidateByEmail(String email) {
        if (email == null)
            return;
        String ek = emailKey(email);
        try {
            String token = redisTemplate.opsForValue().get(ek);
            redisTemplate.delete(ek);
            if (token != null) {
                redisTemplate.delete(tokenKey(token));
            }
            logger.info("Invalidated password reset token for email={}", email);
        } catch (Exception e) {
            logger.warn("Failed to invalidate password reset token for email={}", email, e);
        }
    }

    /**
     * Hủy token theo token value (nếu cần).
     * 
     * @param token token cần hủy
     */
    public void invalidateByToken(String token) {
        if (token == null)
            return;
        String tk = tokenKey(token);
        try {
            String email = redisTemplate.opsForValue().get(tk);
            redisTemplate.delete(tk);
            if (email != null) {
                redisTemplate.delete(emailKey(email));
            }
            logger.info("Invalidated password reset token");
        } catch (Exception e) {
            logger.warn("Failed to invalidate password reset token", e);
        }
    }
}
